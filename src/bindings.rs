/* automatically generated by rust-bindgen 0.58.1 */

pub const RAFT_REQUESTVOTE_ERR_GRANTED: u32 = 1;
pub const RAFT_REQUESTVOTE_ERR_NOT_GRANTED: u32 = 0;
pub const RAFT_REQUESTVOTE_ERR_UNKNOWN_NODE: i32 = -1;
pub const RAFT_SNAPSHOT_NONBLOCKING_APPLY: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Unique entry ids are mostly used for debugging and nothing else,"]
#[doc = " so there is little harm if they collide."]
pub type raft_entry_id_t = ::std::os::raw::c_int;
#[doc = " Monotonic term counter."]
pub type raft_term_t = ::std::os::raw::c_long;
#[doc = " Monotonic log entry index."]
#[doc = ""]
#[doc = " This is also used to as an entry count size type."]
pub type raft_index_t = ::std::os::raw::c_long;
#[doc = " Unique node identifier."]
pub type raft_node_id_t = ::std::os::raw::c_int;
pub const raft_error_e_RAFT_ERR_NOT_LEADER: raft_error_e = -2;
pub const raft_error_e_RAFT_ERR_ONE_VOTING_CHANGE_ONLY: raft_error_e = -3;
pub const raft_error_e_RAFT_ERR_SHUTDOWN: raft_error_e = -4;
pub const raft_error_e_RAFT_ERR_NOMEM: raft_error_e = -5;
pub const raft_error_e_RAFT_ERR_NEEDS_SNAPSHOT: raft_error_e = -6;
pub const raft_error_e_RAFT_ERR_SNAPSHOT_IN_PROGRESS: raft_error_e = -7;
pub const raft_error_e_RAFT_ERR_SNAPSHOT_ALREADY_LOADED: raft_error_e = -8;
pub const raft_error_e_RAFT_ERR_LAST: raft_error_e = -100;
pub type raft_error_e = ::std::os::raw::c_int;
pub const raft_membership_e_RAFT_MEMBERSHIP_ADD: raft_membership_e = 0;
pub const raft_membership_e_RAFT_MEMBERSHIP_REMOVE: raft_membership_e = 1;
pub type raft_membership_e = ::std::os::raw::c_uint;
pub const raft_state_e_RAFT_STATE_NONE: raft_state_e = 0;
pub const raft_state_e_RAFT_STATE_FOLLOWER: raft_state_e = 1;
pub const raft_state_e_RAFT_STATE_CANDIDATE: raft_state_e = 2;
pub const raft_state_e_RAFT_STATE_LEADER: raft_state_e = 3;
pub type raft_state_e = ::std::os::raw::c_uint;
#[doc = " Regular log type."]
#[doc = " This is solely for application data intended for the FSM."]
pub const raft_logtype_e_RAFT_LOGTYPE_NORMAL: raft_logtype_e = 0;
#[doc = " Membership change."]
#[doc = " Non-voting nodes can't cast votes or start elections."]
#[doc = " Nodes in this non-voting state are used to catch up with the cluster,"]
#[doc = " when trying to the join the cluster."]
pub const raft_logtype_e_RAFT_LOGTYPE_ADD_NONVOTING_NODE: raft_logtype_e = 1;
#[doc = " Membership change."]
#[doc = " Add a voting node."]
pub const raft_logtype_e_RAFT_LOGTYPE_ADD_NODE: raft_logtype_e = 2;
#[doc = " Membership change."]
#[doc = " Nodes become demoted when we want to remove them from the cluster."]
#[doc = " Demoted nodes can't take part in voting or start elections."]
#[doc = " Demoted nodes become inactive, as per raft_node_is_active."]
pub const raft_logtype_e_RAFT_LOGTYPE_DEMOTE_NODE: raft_logtype_e = 3;
#[doc = " Membership change."]
#[doc = " The node is removed from the cluster."]
#[doc = " This happens after the node has been demoted."]
#[doc = " Removing nodes is a 2 step process: first demote, then remove."]
pub const raft_logtype_e_RAFT_LOGTYPE_REMOVE_NODE: raft_logtype_e = 4;
#[doc = " Users can piggyback the entry mechanism by specifying log types that"]
#[doc = " are higher than RAFT_LOGTYPE_NUM."]
pub const raft_logtype_e_RAFT_LOGTYPE_NUM: raft_logtype_e = 100;
pub type raft_logtype_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_entry_data_t {
    pub buf: *mut ::std::os::raw::c_void,
    pub len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_raft_entry_data_t() {
    assert_eq!(
        ::std::mem::size_of::<raft_entry_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(raft_entry_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<raft_entry_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(raft_entry_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_data_t>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_data_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_data_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_data_t),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Entry that is stored in the server's entry log."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_entry_t {
    #[doc = " the entry's term at the point it was created"]
    pub term: raft_term_t,
    #[doc = " the entry's unique ID"]
    pub id: raft_entry_id_t,
    #[doc = " type of entry"]
    pub type_: ::std::os::raw::c_int,
    pub data: raft_entry_data_t,
}
#[test]
fn bindgen_test_layout_raft_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<raft_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(raft_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<raft_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(raft_entry_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_t>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_t>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_t>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_entry_t>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_entry_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Message sent from client to server."]
#[doc = " The client sends this message to a server with the intention of having it"]
#[doc = " applied to the FSM."]
pub type msg_entry_t = raft_entry_t;
#[doc = " Entry message response."]
#[doc = " Indicates to client if entry was committed or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_entry_response_t {
    #[doc = " the entry's unique ID"]
    pub id: raft_entry_id_t,
    #[doc = " the entry's term"]
    pub term: raft_term_t,
    #[doc = " the entry's index"]
    pub idx: raft_index_t,
}
#[test]
fn bindgen_test_layout_msg_entry_response_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_entry_response_t>(),
        24usize,
        concat!("Size of: ", stringify!(msg_entry_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_entry_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_entry_response_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_entry_response_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_entry_response_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_entry_response_t>())).term as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_entry_response_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_entry_response_t>())).idx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_entry_response_t),
            "::",
            stringify!(idx)
        )
    );
}
#[doc = " Vote request message."]
#[doc = " Sent to nodes when a server wants to become leader."]
#[doc = " This message could force a leader/candidate to become a follower."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_requestvote_t {
    #[doc = " currentTerm, to force other leader/candidate to step down"]
    pub term: raft_term_t,
    #[doc = " candidate requesting vote"]
    pub candidate_id: raft_node_id_t,
    #[doc = " index of candidate's last log entry"]
    pub last_log_idx: raft_index_t,
    #[doc = " term of candidate's last log entry"]
    pub last_log_term: raft_term_t,
}
#[test]
fn bindgen_test_layout_msg_requestvote_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_requestvote_t>(),
        32usize,
        concat!("Size of: ", stringify!(msg_requestvote_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_requestvote_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_requestvote_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_requestvote_t>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_requestvote_t>())).candidate_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_t),
            "::",
            stringify!(candidate_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_requestvote_t>())).last_log_idx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_t),
            "::",
            stringify!(last_log_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_requestvote_t>())).last_log_term as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_t),
            "::",
            stringify!(last_log_term)
        )
    );
}
#[doc = " Vote request response message."]
#[doc = " Indicates if node has accepted the server's vote request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_requestvote_response_t {
    #[doc = " currentTerm, for candidate to update itself"]
    pub term: raft_term_t,
    #[doc = " true means candidate received vote"]
    pub vote_granted: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msg_requestvote_response_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_requestvote_response_t>(),
        16usize,
        concat!("Size of: ", stringify!(msg_requestvote_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_requestvote_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_requestvote_response_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_requestvote_response_t>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_response_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_requestvote_response_t>())).vote_granted as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_requestvote_response_t),
            "::",
            stringify!(vote_granted)
        )
    );
}
#[doc = " Appendentries message."]
#[doc = " This message is used to tell nodes if it's safe to apply entries to the FSM."]
#[doc = " Can be sent without any entries as a keep alive message."]
#[doc = " This message could force a leader/candidate to become a follower."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_appendentries_t {
    #[doc = " currentTerm, to force other leader/candidate to step down"]
    pub term: raft_term_t,
    #[doc = " the index of the log just before the newest entry for the node who"]
    #[doc = " receives this message"]
    pub prev_log_idx: raft_index_t,
    #[doc = " the term of the log just before the newest entry for the node who"]
    #[doc = " receives this message"]
    pub prev_log_term: raft_term_t,
    #[doc = " the index of the entry that has been appended to the majority of the"]
    #[doc = " cluster. Entries up to this index will be applied to the FSM"]
    pub leader_commit: raft_index_t,
    #[doc = " number of entries within this message"]
    pub n_entries: ::std::os::raw::c_int,
    #[doc = " array of entries within this message"]
    pub entries: *mut msg_entry_t,
}
#[test]
fn bindgen_test_layout_msg_appendentries_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_appendentries_t>(),
        48usize,
        concat!("Size of: ", stringify!(msg_appendentries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_appendentries_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_appendentries_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_appendentries_t>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_t>())).prev_log_idx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(prev_log_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_t>())).prev_log_term as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(prev_log_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_t>())).leader_commit as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(leader_commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_appendentries_t>())).n_entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(n_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_appendentries_t>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_t),
            "::",
            stringify!(entries)
        )
    );
}
#[doc = " Appendentries response message."]
#[doc = " Can be sent without any entries as a keep alive message."]
#[doc = " This message could force a leader/candidate to become a follower."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_appendentries_response_t {
    #[doc = " currentTerm, to force other leader/candidate to step down"]
    pub term: raft_term_t,
    #[doc = " true if follower contained entry matching prevLogidx and prevLogTerm"]
    pub success: ::std::os::raw::c_int,
    #[doc = " If success, this is the highest log IDX we've received and appended to"]
    #[doc = " our log; otherwise, this is the our currentIndex"]
    pub current_idx: raft_index_t,
    #[doc = " The first idx that we received within the appendentries message"]
    pub first_idx: raft_index_t,
}
#[test]
fn bindgen_test_layout_msg_appendentries_response_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_appendentries_response_t>(),
        32usize,
        concat!("Size of: ", stringify!(msg_appendentries_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_appendentries_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_appendentries_response_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_response_t>())).term as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_response_t),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_response_t>())).success as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_response_t),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_response_t>())).current_idx as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_response_t),
            "::",
            stringify!(current_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msg_appendentries_response_t>())).first_idx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_appendentries_response_t),
            "::",
            stringify!(first_idx)
        )
    );
}
pub type raft_server_t = *mut ::std::os::raw::c_void;
pub type raft_node_t = *mut ::std::os::raw::c_void;
#[doc = " Callback for sending request vote messages."]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] node The node's ID that we are sending this message to"]
#[doc = " @param[in] msg The request vote message to be sent"]
#[doc = " @return 0 on success"]
pub type func_send_requestvote_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut raft_node_t,
        msg: *mut msg_requestvote_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for sending append entries messages."]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] node The node's ID that we are sending this message to"]
#[doc = " @param[in] msg The appendentries message to be sent"]
#[doc = " @return 0 on success"]
pub type func_send_appendentries_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut raft_node_t,
        msg: *mut msg_appendentries_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Log compaction"]
#[doc = " Callback for telling the user to send a snapshot."]
#[doc = ""]
#[doc = " @param[in] raft Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] node Node's ID that needs a snapshot sent to"]
pub type func_send_snapshot_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut raft_node_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for detecting when non-voting nodes have obtained enough logs."]
#[doc = " This triggers only when there are no pending configuration changes."]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] node The node"]
#[doc = " @return 0 does not want to be notified again; otherwise -1"]
pub type func_node_has_sufficient_logs_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut raft_node_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for providing debug logging information."]
#[doc = " This callback is optional"]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] node The node that is the subject of this log. Could be NULL."]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] buf The buffer that was logged"]
pub type func_log_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        node: *mut raft_node_t,
        user_data: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Callback for saving who we voted for to disk."]
#[doc = " For safety reasons this callback MUST flush the change to disk."]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] vote The node we voted for"]
#[doc = " @return 0 on success"]
pub type func_persist_vote_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        vote: raft_node_id_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for saving current term (and nil vote) to disk."]
#[doc = " For safety reasons this callback MUST flush the term and vote changes to"]
#[doc = " disk atomically."]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] term Current term"]
#[doc = " @param[in] vote The node value dictating we haven't voted for anybody"]
#[doc = " @return 0 on success"]
pub type func_persist_term_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        term: raft_term_t,
        vote: raft_node_id_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for saving log entry changes."]
#[doc = ""]
#[doc = " This callback is used for:"]
#[doc = " <ul>"]
#[doc = "      <li>Adding entries to the log (ie. offer)</li>"]
#[doc = "      <li>Removing the first entry from the log (ie. polling)</li>"]
#[doc = "      <li>Removing the last entry from the log (ie. popping)</li>"]
#[doc = "      <li>Applying entries</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " For safety reasons this callback MUST flush the change to disk."]
#[doc = ""]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] entry The entry that the event is happening to."]
#[doc = "    For offering, polling, and popping, the user is allowed to change the"]
#[doc = "    memory pointed to in the raft_entry_data_t struct. This MUST be done if"]
#[doc = "    the memory is temporary."]
#[doc = " @param[in] entry_idx The entries index in the log"]
#[doc = " @return 0 on success"]
pub type func_logentry_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        entry: *mut raft_entry_t,
        entry_idx: raft_index_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback for being notified of membership changes."]
#[doc = ""]
#[doc = " Implementing this callback is optional."]
#[doc = ""]
#[doc = " Remove notification happens before the node is about to be removed."]
#[doc = ""]
#[doc = " @param[in] raft The Raft server making this callback"]
#[doc = " @param[in] user_data User data that is passed from Raft server"]
#[doc = " @param[in] node The node that is the subject of this log. Could be NULL."]
#[doc = " @param[in] entry The entry that was the trigger for the event. Could be NULL."]
#[doc = " @param[in] type The type of membership change"]
pub type func_membership_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        raft: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut raft_node_t,
        entry: *mut raft_entry_t,
        type_: raft_membership_e,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_cbs_t {
    #[doc = " Callback for sending request vote messages"]
    pub send_requestvote: func_send_requestvote_f,
    #[doc = " Callback for sending appendentries messages"]
    pub send_appendentries: func_send_appendentries_f,
    #[doc = " Callback for notifying user that a node needs a snapshot sent"]
    pub send_snapshot: func_send_snapshot_f,
    #[doc = " Callback for finite state machine application"]
    #[doc = " Return 0 on success."]
    #[doc = " Return RAFT_ERR_SHUTDOWN if you want the server to shutdown."]
    pub applylog: func_logentry_event_f,
    #[doc = " Callback for persisting vote data"]
    #[doc = " For safety reasons this callback MUST flush the change to disk."]
    pub persist_vote: func_persist_vote_f,
    #[doc = " Callback for persisting term (and nil vote) data"]
    #[doc = " For safety reasons this callback MUST flush the term and vote changes to"]
    #[doc = " disk atomically."]
    pub persist_term: func_persist_term_f,
    #[doc = " Callback for adding an entry to the log"]
    #[doc = " For safety reasons this callback MUST flush the change to disk."]
    #[doc = " Return 0 on success."]
    #[doc = " Return RAFT_ERR_SHUTDOWN if you want the server to shutdown."]
    pub log_offer: func_logentry_event_f,
    #[doc = " Callback for removing the oldest entry from the log"]
    #[doc = " For safety reasons this callback MUST flush the change to disk."]
    #[doc = " @note If memory was malloc'd in log_offer then this should be the right"]
    #[doc = "  time to free the memory."]
    pub log_poll: func_logentry_event_f,
    #[doc = " Callback for removing the youngest entry from the log"]
    #[doc = " For safety reasons this callback MUST flush the change to disk."]
    #[doc = " @note If memory was malloc'd in log_offer then this should be the right"]
    #[doc = "  time to free the memory."]
    pub log_pop: func_logentry_event_f,
    #[doc = " Callback called for every existing log entry when clearing the log."]
    #[doc = " If memory was malloc'd in log_offer and the entry doesn't get a chance"]
    #[doc = " to go through log_poll or log_pop, this is the last chance to free it."]
    pub log_clear: func_logentry_event_f,
    #[doc = " Callback for determining which node this configuration log entry"]
    #[doc = " affects. This call only applies to configuration change log entries."]
    #[doc = " @return the node ID of the node"]
    pub log_get_node_id: func_logentry_event_f,
    #[doc = " Callback for detecting when a non-voting node has sufficient logs."]
    pub node_has_sufficient_logs: func_node_has_sufficient_logs_f,
    pub notify_membership_event: func_membership_event_f,
    #[doc = " Callback for catching debugging log messages"]
    #[doc = " This callback is optional"]
    pub log: func_log_f,
}
#[test]
fn bindgen_test_layout_raft_cbs_t() {
    assert_eq!(
        ::std::mem::size_of::<raft_cbs_t>(),
        112usize,
        concat!("Size of: ", stringify!(raft_cbs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<raft_cbs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(raft_cbs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).send_requestvote as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(send_requestvote)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).send_appendentries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(send_appendentries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).send_snapshot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(send_snapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).applylog as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(applylog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).persist_vote as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(persist_vote)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).persist_term as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(persist_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log_offer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log_offer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log_poll as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log_pop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log_pop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log_clear as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log_get_node_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log_get_node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_cbs_t>())).node_has_sufficient_logs as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(node_has_sufficient_logs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_cbs_t>())).notify_membership_event as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(notify_membership_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_cbs_t>())).log as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_cbs_t),
            "::",
            stringify!(log)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_node_configuration_t {
    #[doc = " User data pointer for addressing."]
    #[doc = " Examples of what this could be:"]
    #[doc = " - void* pointing to implementor's networking data"]
    #[doc = " - a (IP,Port) tuple"]
    pub udata_address: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_raft_node_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<raft_node_configuration_t>(),
        8usize,
        concat!("Size of: ", stringify!(raft_node_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<raft_node_configuration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(raft_node_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_node_configuration_t>())).udata_address as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_node_configuration_t),
            "::",
            stringify!(udata_address)
        )
    );
}
extern "C" {
    #[doc = " Initialise a new Raft server."]
    #[doc = ""]
    #[doc = " Request timeout defaults to 200 milliseconds"]
    #[doc = " Election timeout defaults to 1000 milliseconds"]
    #[doc = ""]
    #[doc = " @return newly initialised Raft server"]
    pub fn raft_new() -> *mut raft_server_t;
}
extern "C" {
    #[doc = " De-initialise Raft server."]
    #[doc = " Frees all memory"]
    pub fn raft_free(me: *mut raft_server_t);
}
extern "C" {
    #[doc = " De-initialise Raft server."]
    pub fn raft_clear(me: *mut raft_server_t);
}
extern "C" {
    #[doc = " Set callbacks and user data."]
    #[doc = ""]
    #[doc = " @param[in] funcs Callbacks"]
    #[doc = " @param[in] user_data \"User data\" - user's context that's included in a callback"]
    pub fn raft_set_callbacks(
        me: *mut raft_server_t,
        funcs: *mut raft_cbs_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Add node."]
    #[doc = ""]
    #[doc = " If a voting node already exists the call will fail."]
    #[doc = ""]
    #[doc = " @note The order this call is made is important."]
    #[doc = "  This call MUST be made in the same order as the other raft nodes."]
    #[doc = "  This is because the node ID is assigned depending on when this call is made"]
    #[doc = ""]
    #[doc = " @param[in] user_data The user data for the node."]
    #[doc = "  This is obtained using raft_node_get_udata."]
    #[doc = "  Examples of what this could be:"]
    #[doc = "  - void* pointing to implementor's networking data"]
    #[doc = "  - a (IP,Port) tuple"]
    #[doc = " @param[in] id The integer ID of this node"]
    #[doc = "  This is used for identifying clients across sessions."]
    #[doc = " @param[in] is_self Set to 1 if this \"node\" is this server"]
    #[doc = " @return"]
    #[doc = "  node if it was successfully added;"]
    #[doc = "  NULL if the node already exists"]
    pub fn raft_add_node(
        me: *mut raft_server_t,
        user_data: *mut ::std::os::raw::c_void,
        id: raft_node_id_t,
        is_self: ::std::os::raw::c_int,
    ) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " Add a node which does not participate in voting."]
    #[doc = " If a node already exists the call will fail."]
    #[doc = " Parameters are identical to raft_add_node"]
    #[doc = " @return"]
    #[doc = "  node if it was successfully added;"]
    #[doc = "  NULL if the node already exists"]
    pub fn raft_add_non_voting_node(
        me_: *mut raft_server_t,
        udata: *mut ::std::os::raw::c_void,
        id: raft_node_id_t,
        is_self: ::std::os::raw::c_int,
    ) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " Remove node."]
    #[doc = " @param node The node to be removed."]
    pub fn raft_remove_node(me_: *mut raft_server_t, node: *mut raft_node_t);
}
extern "C" {
    #[doc = " Set election timeout."]
    #[doc = " The amount of time that needs to elapse before we assume the leader is down"]
    #[doc = " @param[in] msec Election timeout in milliseconds"]
    pub fn raft_set_election_timeout(me: *mut raft_server_t, msec: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set request timeout in milliseconds."]
    #[doc = " The amount of time before we resend an appendentries message"]
    #[doc = " @param[in] msec Request timeout in milliseconds"]
    pub fn raft_set_request_timeout(me: *mut raft_server_t, msec: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Process events that are dependent on time passing."]
    #[doc = " @param[in] msec_elapsed Time in milliseconds since the last call"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  -1 on failure;"]
    #[doc = "  RAFT_ERR_SHUTDOWN when server MUST shutdown"]
    pub fn raft_periodic(
        me: *mut raft_server_t,
        msec_elapsed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive an appendentries message."]
    #[doc = ""]
    #[doc = " Will block (ie. by syncing to disk) if we need to append a message."]
    #[doc = ""]
    #[doc = " Might call malloc once to increase the log entry array size."]
    #[doc = ""]
    #[doc = " The log_offer callback will be called."]
    #[doc = ""]
    #[doc = " @note The memory pointer (ie. raft_entry_data_t) for each msg_entry_t is"]
    #[doc = "   copied directly. If the memory is temporary you MUST either make the"]
    #[doc = "   memory permanent (ie. via malloc) OR re-assign the memory within the"]
    #[doc = "   log_offer callback."]
    #[doc = ""]
    #[doc = " @param[in] node The node who sent us this message"]
    #[doc = " @param[in] ae The appendentries message"]
    #[doc = " @param[out] r The resulting response"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  RAFT_ERR_NEEDS_SNAPSHOT"]
    pub fn raft_recv_appendentries(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
        ae: *mut msg_appendentries_t,
        r: *mut msg_appendentries_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a response from an appendentries message we sent."]
    #[doc = " @param[in] node The node who sent us this message"]
    #[doc = " @param[in] r The appendentries response message"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  -1 on error;"]
    #[doc = "  RAFT_ERR_NOT_LEADER server is not the leader"]
    pub fn raft_recv_appendentries_response(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
        r: *mut msg_appendentries_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a requestvote message."]
    #[doc = " @param[in] node The node who sent us this message"]
    #[doc = " @param[in] vr The requestvote message"]
    #[doc = " @param[out] r The resulting response"]
    #[doc = " @return 0 on success"]
    pub fn raft_recv_requestvote(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
        vr: *mut msg_requestvote_t,
        r: *mut msg_requestvote_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a response from a requestvote message we sent."]
    #[doc = " @param[in] node The node this response was sent by"]
    #[doc = " @param[in] r The requestvote response message"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  RAFT_ERR_SHUTDOWN server MUST shutdown;"]
    pub fn raft_recv_requestvote_response(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
        r: *mut msg_requestvote_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive an entry message from the client."]
    #[doc = ""]
    #[doc = " Append the entry to the log and send appendentries to followers."]
    #[doc = ""]
    #[doc = " Will block (ie. by syncing to disk) if we need to append a message."]
    #[doc = ""]
    #[doc = " Might call malloc once to increase the log entry array size."]
    #[doc = ""]
    #[doc = " The log_offer callback will be called."]
    #[doc = ""]
    #[doc = " @note The memory pointer (ie. raft_entry_data_t) in msg_entry_t is"]
    #[doc = "  copied directly. If the memory is temporary you MUST either make the"]
    #[doc = "  memory permanent (ie. via malloc) OR re-assign the memory within the"]
    #[doc = "  log_offer callback."]
    #[doc = ""]
    #[doc = " Will fail:"]
    #[doc = " <ul>"]
    #[doc = "      <li>if the server is not the leader"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param[in] node The node who sent us this message"]
    #[doc = " @param[in] ety The entry message"]
    #[doc = " @param[out] r The resulting response"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  RAFT_ERR_NOT_LEADER server is not the leader;"]
    #[doc = "  RAFT_ERR_SHUTDOWN server MUST shutdown;"]
    #[doc = "  RAFT_ERR_ONE_VOTING_CHANGE_ONLY there is a non-voting change inflight;"]
    #[doc = "  RAFT_ERR_NOMEM memory allocation failure"]
    pub fn raft_recv_entry(
        me: *mut raft_server_t,
        ety: *mut msg_entry_t,
        r: *mut msg_entry_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return server's node ID; -1 if it doesn't know what it is"]
    pub fn raft_get_nodeid(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the server's node"]
    pub fn raft_get_my_node(me_: *mut raft_server_t) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " @return currently configured election timeout in milliseconds"]
    pub fn raft_get_election_timeout(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of nodes that this server has"]
    pub fn raft_get_num_nodes(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of voting nodes that this server has"]
    pub fn raft_get_num_voting_nodes(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of items within log"]
    pub fn raft_get_log_count(me: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return current term"]
    pub fn raft_get_current_term(me: *mut raft_server_t) -> raft_term_t;
}
extern "C" {
    #[doc = " @return current log index"]
    pub fn raft_get_current_idx(me: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return commit index"]
    pub fn raft_get_commit_idx(me_: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return 1 if follower; 0 otherwise"]
    pub fn raft_is_follower(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return 1 if leader; 0 otherwise"]
    pub fn raft_is_leader(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return 1 if candidate; 0 otherwise"]
    pub fn raft_is_candidate(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return currently elapsed timeout in milliseconds"]
    pub fn raft_get_timeout_elapsed(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return request timeout in milliseconds"]
    pub fn raft_get_request_timeout(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return index of last applied entry"]
    pub fn raft_get_last_applied_idx(me: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return the node's next index"]
    pub fn raft_node_get_next_idx(node: *mut raft_node_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return this node's user data"]
    pub fn raft_node_get_match_idx(me: *mut raft_node_t) -> raft_index_t;
}
extern "C" {
    #[doc = " @return this node's user data"]
    pub fn raft_node_get_udata(me: *mut raft_node_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set this node's user data"]
    pub fn raft_node_set_udata(me: *mut raft_node_t, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @param[in] idx The entry's index"]
    #[doc = " @return entry from index"]
    pub fn raft_get_entry_from_idx(me: *mut raft_server_t, idx: raft_index_t) -> *mut raft_entry_t;
}
extern "C" {
    #[doc = " @param[in] node The node's ID"]
    #[doc = " @return node pointed to by node ID"]
    pub fn raft_get_node(me_: *mut raft_server_t, id: raft_node_id_t) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " Used for iterating through nodes"]
    #[doc = " @param[in] node The node's idx"]
    #[doc = " @return node pointed to by node idx"]
    pub fn raft_get_node_from_idx(me_: *mut raft_server_t, idx: raft_index_t) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " @return number of votes this server has received this election"]
    pub fn raft_get_nvotes_for_me(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return node ID of who I voted for"]
    pub fn raft_get_voted_for(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get what this node thinks the node ID of the leader is."]
    #[doc = " @return node of what this node thinks is the valid leader;"]
    #[doc = "   -1 if the leader is unknown"]
    pub fn raft_get_current_leader(me: *mut raft_server_t) -> raft_node_id_t;
}
extern "C" {
    #[doc = " Get what this node thinks the node of the leader is."]
    #[doc = " @return node of what this node thinks is the valid leader;"]
    #[doc = "   NULL if the leader is unknown"]
    pub fn raft_get_current_leader_node(me: *mut raft_server_t) -> *mut raft_node_t;
}
extern "C" {
    #[doc = " @return callback user data"]
    pub fn raft_get_udata(me: *mut raft_server_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Vote for a server."]
    #[doc = " This should be used to reload persistent state, ie. the voted-for field."]
    #[doc = " @param[in] node The server to vote for"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    pub fn raft_vote(me_: *mut raft_server_t, node: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Vote for a server."]
    #[doc = " This should be used to reload persistent state, ie. the voted-for field."]
    #[doc = " @param[in] nodeid The server to vote for by nodeid"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    pub fn raft_vote_for_nodeid(
        me_: *mut raft_server_t,
        nodeid: raft_node_id_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the current term."]
    #[doc = " This should be used to reload persistent state, ie. the current_term field."]
    #[doc = " @param[in] term The new current term"]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    pub fn raft_set_current_term(
        me: *mut raft_server_t,
        term: raft_term_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the commit idx."]
    #[doc = " This should be used to reload persistent state, ie. the commit_idx field."]
    #[doc = " @param[in] commit_idx The new commit index."]
    pub fn raft_set_commit_idx(me: *mut raft_server_t, commit_idx: raft_index_t);
}
extern "C" {
    #[doc = " Add an entry to the server's log."]
    #[doc = " This should be used to reload persistent state, ie. the commit log."]
    #[doc = " @param[in] ety The entry to be appended"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  RAFT_ERR_SHUTDOWN server should shutdown"]
    #[doc = "  RAFT_ERR_NOMEM memory allocation failure"]
    pub fn raft_append_entry(
        me: *mut raft_server_t,
        ety: *mut raft_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Confirm if a msg_entry_response has been committed."]
    #[doc = " @param[in] r The response we want to check"]
    pub fn raft_msg_entry_response_committed(
        me_: *mut raft_server_t,
        r: *const msg_entry_response_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get node's ID."]
    #[doc = " @return ID of node"]
    pub fn raft_node_get_id(me_: *mut raft_node_t) -> raft_node_id_t;
}
extern "C" {
    #[doc = " Tell if we are a leader, candidate or follower."]
    #[doc = " @return get state of type raft_state_e."]
    pub fn raft_get_state(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the most recent log's term"]
    #[doc = " @return the last log term"]
    pub fn raft_get_last_log_term(me_: *mut raft_server_t) -> raft_term_t;
}
extern "C" {
    #[doc = " Turn a node into a voting node."]
    #[doc = " Voting nodes can take part in elections and in-regards to committing entries,"]
    #[doc = " are counted in majorities."]
    pub fn raft_node_set_voting(node: *mut raft_node_t, voting: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Tell if a node is a voting node or not."]
    #[doc = " @return 1 if this is a voting node. Otherwise 0."]
    pub fn raft_node_is_voting(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a node has sufficient logs to be able to join the cluster."]
    pub fn raft_node_has_sufficient_logs(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply all entries up to the commit index"]
    #[doc = " @return"]
    #[doc = "  0 on success;"]
    #[doc = "  RAFT_ERR_SHUTDOWN when server MUST shutdown"]
    pub fn raft_apply_all(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Become leader"]
    #[doc = " WARNING: this is a dangerous function call. It could lead to your cluster"]
    #[doc = " losing it's consensus guarantees."]
    pub fn raft_become_leader(me: *mut raft_server_t);
}
extern "C" {
    #[doc = " Become follower. This may be used to give up leadership. It does not change"]
    #[doc = " currentTerm."]
    pub fn raft_become_follower(me: *mut raft_server_t);
}
extern "C" {
    #[doc = " Determine if entry is voting configuration change."]
    #[doc = " @param[in] ety The entry to query."]
    #[doc = " @return 1 if this is a voting configuration change."]
    pub fn raft_entry_is_voting_cfg_change(ety: *mut raft_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if entry is configuration change."]
    #[doc = " @param[in] ety The entry to query."]
    #[doc = " @return 1 if this is a configuration change."]
    pub fn raft_entry_is_cfg_change(ety: *mut raft_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Begin snapshotting."]
    #[doc = ""]
    #[doc = " While snapshotting, raft will:"]
    #[doc = "  - not apply log entries"]
    #[doc = "  - not start elections"]
    #[doc = ""]
    #[doc = " If the RAFT_SNAPSHOT_NONBLOCKING_APPLY flag is specified, log entries will"]
    #[doc = " be applied during snapshot.  The FSM must isolate the snapshot state and"]
    #[doc = " guarantee these changes do not affect it."]
    #[doc = ""]
    #[doc = " @return 0 on success"]
    #[doc = ""]
    pub fn raft_begin_snapshot(
        me_: *mut raft_server_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop snapshotting."]
    #[doc = ""]
    #[doc = " The user MUST include membership changes inside the snapshot. This means"]
    #[doc = " that membership changes are included in the size of the snapshot. For peers"]
    #[doc = " that load the snapshot, the user needs to deserialize the snapshot to"]
    #[doc = " obtain the membership changes."]
    #[doc = ""]
    #[doc = " The user MUST compact the log up to the commit index. This means all"]
    #[doc = " log entries up to the commit index MUST be deleted (aka polled)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure"]
    pub fn raft_end_snapshot(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel snapshotting."]
    #[doc = ""]
    #[doc = " If an error occurs during snapshotting, this function can be called instead"]
    #[doc = " of raft_end_snapshot() to cancel the operation."]
    #[doc = ""]
    #[doc = " The user MUST be sure the original snapshot is left untouched and remains"]
    #[doc = " usable."]
    pub fn raft_cancel_snapshot(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the entry index of the entry that was snapshotted"]
    pub fn raft_get_snapshot_entry_idx(me_: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " Check is a snapshot is in progress"]
    pub fn raft_snapshot_is_in_progress(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if entries can be applied now (no snapshot in progress, or"]
    #[doc = " RAFT_SNAPSHOT_NONBLOCKING_APPLY specified)."]
    pub fn raft_is_apply_allowed(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the first log entry."]
    #[doc = " This should be used for compacting logs."]
    #[doc = " @return 0 on success"]
    pub fn raft_poll_entry(
        me_: *mut raft_server_t,
        ety: *mut *mut raft_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get last applied entry"]
    pub fn raft_get_last_applied_entry(me_: *mut raft_server_t) -> *mut raft_entry_t;
}
extern "C" {
    pub fn raft_get_first_entry_idx(me_: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    #[doc = " Start loading snapshot"]
    #[doc = ""]
    #[doc = " This is usually the result of a snapshot being loaded."]
    #[doc = " We need to send an appendentries response."]
    #[doc = ""]
    #[doc = " This will remove all other nodes (not ourself). The user MUST use the"]
    #[doc = " snapshot to load the new membership information."]
    #[doc = ""]
    #[doc = " @param[in] last_included_term Term of the last log of the snapshot"]
    #[doc = " @param[in] last_included_index Index of the last log of the snapshot"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure"]
    #[doc = "  RAFT_ERR_SNAPSHOT_ALREADY_LOADED"]
    pub fn raft_begin_load_snapshot(
        me_: *mut raft_server_t,
        last_included_term: raft_term_t,
        last_included_index: raft_index_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop loading snapshot."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success"]
    #[doc = "  -1 on failure"]
    pub fn raft_end_load_snapshot(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_get_snapshot_last_idx(me_: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    pub fn raft_get_snapshot_last_term(me_: *mut raft_server_t) -> raft_term_t;
}
extern "C" {
    pub fn raft_set_snapshot_metadata(
        me_: *mut raft_server_t,
        term: raft_term_t,
        idx: raft_index_t,
    );
}
extern "C" {
    #[doc = " Check if a node is active."]
    #[doc = " Active nodes could become voting nodes."]
    #[doc = " This should be used for creating the membership snapshot."]
    pub fn raft_node_is_active(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make the node active."]
    #[doc = ""]
    #[doc = " The user sets this to 1 between raft_begin_load_snapshot and"]
    #[doc = " raft_end_load_snapshot."]
    #[doc = ""]
    #[doc = " @param[in] active Set a node as active if this is 1"]
    pub fn raft_node_set_active(me_: *mut raft_node_t, active: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Check if a node's voting status has been committed."]
    #[doc = " This should be used for creating the membership snapshot."]
    pub fn raft_node_is_voting_committed(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a node's membership to the cluster has been committed."]
    #[doc = " This should be used for creating the membership snapshot."]
    pub fn raft_node_is_addition_committed(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register custom heap management functions, to be used if an alternative"]
    #[doc = " heap management is used."]
    pub fn raft_set_heap_functions(
        _malloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void,
        >,
        _calloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void,
        >,
        _realloc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        _free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Confirm that a node's voting status is final"]
    #[doc = " @param[in] node The node"]
    #[doc = " @param[in] voting Whether this node's voting status is committed or not"]
    pub fn raft_node_set_voting_committed(me_: *mut raft_node_t, voting: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Confirm that a node's voting status is final"]
    #[doc = " @param[in] node The node"]
    #[doc = " @param[in] committed Whether this node's membership is committed or not"]
    pub fn raft_node_set_addition_committed(
        me_: *mut raft_node_t,
        committed: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Check if a voting change is in progress"]
    #[doc = " @param[in] raft The Raft server"]
    #[doc = " @return 1 if a voting change is in progress"]
    pub fn raft_voting_change_is_in_progress(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
pub type log_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn log_new() -> *mut log_t;
}
extern "C" {
    pub fn log_alloc(initial_size: raft_index_t) -> *mut log_t;
}
extern "C" {
    pub fn log_set_callbacks(
        me_: *mut log_t,
        funcs: *mut raft_cbs_t,
        raft: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn log_free(me_: *mut log_t);
}
extern "C" {
    pub fn log_clear(me_: *mut log_t);
}
extern "C" {
    pub fn log_clear_entries(me_: *mut log_t);
}
extern "C" {
    #[doc = " Add entry to log."]
    #[doc = " Don't add entry if we've already added this entry (based off ID)"]
    #[doc = " Don't add entries with ID=0"]
    #[doc = " @return 0 if unsuccessful; 1 otherwise"]
    pub fn log_append_entry(me_: *mut log_t, c: *mut raft_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of entries held within log"]
    pub fn log_count(me_: *mut log_t) -> raft_index_t;
}
extern "C" {
    #[doc = " Delete all logs from this log onwards"]
    pub fn log_delete(me_: *mut log_t, idx: raft_index_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Empty the queue."]
    pub fn log_empty(me_: *mut log_t);
}
extern "C" {
    #[doc = " Remove oldest entry. Set *etyp to oldest entry on success."]
    pub fn log_poll(
        me_: *mut log_t,
        etyp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an array of entries from this index onwards."]
    #[doc = " This is used for batching."]
    pub fn log_get_from_idx(
        me_: *mut log_t,
        idx: raft_index_t,
        n_etys: *mut ::std::os::raw::c_int,
    ) -> *mut raft_entry_t;
}
extern "C" {
    pub fn log_get_at_idx(me_: *mut log_t, idx: raft_index_t) -> *mut raft_entry_t;
}
extern "C" {
    #[doc = " @return youngest entry"]
    pub fn log_peektail(me_: *mut log_t) -> *mut raft_entry_t;
}
extern "C" {
    pub fn log_get_current_idx(me_: *mut log_t) -> raft_index_t;
}
extern "C" {
    pub fn log_load_from_snapshot(
        me_: *mut log_t,
        idx: raft_index_t,
        term: raft_term_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn log_get_base(me_: *mut log_t) -> raft_index_t;
}
pub const RAFT_NODE_STATUS_DISCONNECTED: ::std::os::raw::c_uint = 0;
pub const RAFT_NODE_STATUS_CONNECTED: ::std::os::raw::c_uint = 1;
pub const RAFT_NODE_STATUS_CONNECTING: ::std::os::raw::c_uint = 2;
pub const RAFT_NODE_STATUS_DISCONNECTING: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_server_private_t {
    pub current_term: raft_term_t,
    pub voted_for: raft_node_id_t,
    pub log: *mut ::std::os::raw::c_void,
    pub commit_idx: raft_index_t,
    pub last_applied_idx: raft_index_t,
    pub state: ::std::os::raw::c_int,
    pub timeout_elapsed: ::std::os::raw::c_int,
    pub nodes: *mut raft_node_t,
    pub num_nodes: ::std::os::raw::c_int,
    pub election_timeout: ::std::os::raw::c_int,
    pub election_timeout_rand: ::std::os::raw::c_int,
    pub request_timeout: ::std::os::raw::c_int,
    pub current_leader: *mut raft_node_t,
    pub cb: raft_cbs_t,
    pub udata: *mut ::std::os::raw::c_void,
    pub node: *mut raft_node_t,
    pub voting_cfg_change_log_idx: raft_index_t,
    pub connected: ::std::os::raw::c_int,
    pub snapshot_in_progress: ::std::os::raw::c_int,
    pub snapshot_flags: ::std::os::raw::c_int,
    pub snapshot_last_idx: raft_index_t,
    pub snapshot_last_term: raft_term_t,
    pub saved_snapshot_last_idx: raft_index_t,
    pub saved_snapshot_last_term: raft_term_t,
}
#[test]
fn bindgen_test_layout_raft_server_private_t() {
    assert_eq!(
        ::std::mem::size_of::<raft_server_private_t>(),
        264usize,
        concat!("Size of: ", stringify!(raft_server_private_t))
    );
    assert_eq!(
        ::std::mem::align_of::<raft_server_private_t>(),
        8usize,
        concat!("Alignment of ", stringify!(raft_server_private_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).current_term as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(current_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).voted_for as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(voted_for)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).log as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).commit_idx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(commit_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).last_applied_idx as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(last_applied_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).timeout_elapsed as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(timeout_elapsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).nodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).num_nodes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(num_nodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).election_timeout as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(election_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).election_timeout_rand as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(election_timeout_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).request_timeout as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(request_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).current_leader as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(current_leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).udata as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(udata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).node as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).voting_cfg_change_log_idx as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(voting_cfg_change_log_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raft_server_private_t>())).connected as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).snapshot_in_progress as *const _
                as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(snapshot_in_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).snapshot_flags as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(snapshot_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).snapshot_last_idx as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(snapshot_last_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).snapshot_last_term as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(snapshot_last_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).saved_snapshot_last_idx as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(saved_snapshot_last_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raft_server_private_t>())).saved_snapshot_last_term as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(raft_server_private_t),
            "::",
            stringify!(saved_snapshot_last_term)
        )
    );
}
extern "C" {
    pub fn raft_election_start(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_become_candidate(me: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_randomize_election_timeout(me_: *mut raft_server_t);
}
extern "C" {
    #[doc = " @return 0 on error"]
    pub fn raft_send_requestvote(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_send_appendentries(
        me: *mut raft_server_t,
        node: *mut raft_node_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_send_appendentries_all(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply entry at lastApplied + 1. Entry becomes 'committed'."]
    #[doc = " @return 1 if entry committed, 0 otherwise"]
    pub fn raft_apply_entry(me_: *mut raft_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_set_last_applied_idx(me: *mut raft_server_t, idx: raft_index_t);
}
extern "C" {
    pub fn raft_set_state(me_: *mut raft_server_t, state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn raft_node_new(
        udata: *mut ::std::os::raw::c_void,
        id: raft_node_id_t,
    ) -> *mut raft_node_t;
}
extern "C" {
    pub fn raft_node_free(me_: *mut raft_node_t);
}
extern "C" {
    pub fn raft_node_set_next_idx(node: *mut raft_node_t, nextIdx: raft_index_t);
}
extern "C" {
    pub fn raft_node_set_match_idx(node: *mut raft_node_t, matchIdx: raft_index_t);
}
extern "C" {
    pub fn raft_node_vote_for_me(me_: *mut raft_node_t, vote: ::std::os::raw::c_int);
}
extern "C" {
    pub fn raft_node_has_vote_for_me(me_: *mut raft_node_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_node_set_has_sufficient_logs(me_: *mut raft_node_t);
}
extern "C" {
    pub fn raft_votes_is_majority(
        nnodes: ::std::os::raw::c_int,
        nvotes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_offer_log(me_: *mut raft_server_t, ety: *mut raft_entry_t, idx: raft_index_t);
}
extern "C" {
    pub fn raft_pop_log(me_: *mut raft_server_t, ety: *mut raft_entry_t, idx: raft_index_t);
}
extern "C" {
    pub fn raft_get_num_snapshottable_logs(me_: *mut raft_server_t) -> raft_index_t;
}
extern "C" {
    pub static mut __raft_malloc:
        ::std::option::Option<unsafe extern "C" fn(size: size_t) -> *mut ::std::os::raw::c_void>;
}
extern "C" {
    pub static mut __raft_calloc: ::std::option::Option<
        unsafe extern "C" fn(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __raft_realloc: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *mut ::std::os::raw::c_void,
            size: size_t,
        ) -> *mut ::std::os::raw::c_void,
    >;
}
extern "C" {
    pub static mut __raft_free:
        ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
}
